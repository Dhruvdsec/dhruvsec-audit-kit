# SPDX License Identifiers in Solidity (Simplified)

## ğŸ” Why License Matters

When you open-source a smart contract, youâ€™re giving others permission to read, reuse, or build upon your code â€” but only under certain legal terms. Thatâ€™s where SPDX license identifiers come in.

### âœ… Syntax (Put this at the top of every `.sol` file):

```solidity
// SPDX-License-Identifier: MIT
```

This tells the compiler (and the world):

> â€œIâ€™m open-sourcing this file under the MIT License.â€

## ğŸ“š Common SPDX License Types

| SPDX Tag     | Meaning                                                                    |
| ------------ | -------------------------------------------------------------------------- |
| `MIT`        | Super permissive. You can use, copy, modify, distribute. Just give credit. |
| `GPL-3.0`    | Free to use, but **must open-source** derivative works.                    |
| `Apache-2.0` | Similar to MIT but with extra legal protections (like patent rights).      |
| `UNLICENSED` | You are **not** allowing others to use or reuse the code.                  |
| `UNLICENSE`  | You are granting **all rights** to everyone â€” public domain.               |

### âš ï¸ Note:

* `UNLICENSED` â‰  `UNLICENSE` â€” donâ€™t get confused
* Compiler doesnâ€™t validate the license â€” it just attaches your string to the compiled bytecode
* SPDX tag is machine-readable, good for tooling, scanners, and legal audits

### ğŸ“Œ Best Practices:

* Always add the SPDX license identifier in production code
* Put it at the very top of every file, before the pragma
* Pick the license based on how much freedom you're giving others

### âœ… Example:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract HelloWorld {
    string public greet = "Hello, world!";
}
```

---

# âš™ï¸ `pragma` in Solidity â€” Explained

The `pragma` keyword in Solidity is like a compiler instruction. It tells the Solidity compiler to enable specific features or checks for that particular source file.

### ğŸ§  Key Points:

* `pragma` applies **only** to the file itâ€™s written in
* It does **not** carry over to imported files
* You need to repeat it in every `.sol` file where it matters

### âœ… Most Common: Solidity Version Pragma

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
```

This tells the compiler:

> â€œCompile this file using Solidity version 0.8.20 or compatible upward versionsâ€

You can also specify version ranges:

```solidity
pragma solidity >=0.8.0 <0.9.0;
```

## âš™ï¸ Common `pragma` Directives in Solidity

| Pragma                      | Purpose                                             |
| --------------------------- | --------------------------------------------------- |
| `abicoder v2`               | Enables ABI encoder v2 (default from Solidity 0.8+) |
| `experimental SMTChecker`   | Enables formal verification via SMT solver          |
| `experimental ABIEncoderV2` | Old version for encoder v2 (âš ï¸ deprecated)          |

### âš ï¸ Best Practices:

* Always lock the compiler version in production contracts (e.g., `^0.8.20`) to avoid unexpected behavior
* Use a version range in dev if working across multiple contracts
* Donâ€™t assume `pragma` in one file affects others â€” be explicit!

### âœ… Real Example:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import "./Utils.sol";  // Must also have its own pragma
```

Even if `Utils.sol` has pragma, you must still declare pragma in your main file.

---

# ğŸ”„ `pragma abicoder v1` vs `v2` â€” ABI Encoder in Solidity

Solidity smart contracts need to encode and decode data when calling functions or returning results â€” especially when structs, arrays, or nested data types are involved. This is handled by the ABI Encoder.

### âœ… Syntax:

```solidity
pragma abicoder v2;
// or
pragma abicoder v1;
```

### âœ… Why It Matters:

* `v2` supports nested structs and arrays
* `v1` does **not** support these
* `v2` has more safety checks (but may cost more gas)

> Since Solidity `0.8.0`, `v2` is enabled by default

---

# ğŸ§ª Experimental Pragmas in Solidity

Experimental pragmas are used to enable **advanced** or **in-development** features of the Solidity compiler â€” stuff thatâ€™s not yet enabled by default.

### âœ… Syntax:

```solidity
pragma experimental SMTChecker;
```

They are **file-local**, just like other pragmas.

## ğŸ§  Currently Supported Experimental Pragmas

### 1. ğŸš« `ABIEncoderV2` (Deprecated as Experimental)

```solidity
pragma experimental ABIEncoderV2;
```

* Old way to enable support for nested arrays and structs
* Not needed in Solidity 0.8.0+
* Use **only** if youâ€™re stuck using 0.6.x or 0.7.x

### 2. ğŸ§  `SMTChecker` â€” Formal Verification

```solidity
pragma experimental SMTChecker;
```

#### What It Does:

* Enables formal verification using SMT solvers like Z3
* Checks for:

  * Assertion failures
  * Integer overflows
  * Unreachable code

#### ğŸ”¥ Real Use Case:

If youâ€™re writing **critical DeFi contracts** or doing audits, SMTChecker can detect:

* Integer overflows (even without SafeMath)
* Dead code
* Logical errors pre-runtime

#### ğŸ› ï¸ How to Use It:

You need a compiler that was **built with SMT support**

* âœ… Available in: Ubuntu PPA versions
* âŒ Not in: Docker, Windows binaries, static Linux builds

If using `solc-js`:

* Enable via `smtCallback` (with a local solver)
* Wonâ€™t work in-browser (e.g., Remix)

### âš ï¸ Important:

Experimental pragmas are **not for beginners**
Only use them if:

* Youâ€™re on a compatible compiler
* You understand what the feature does
* Youâ€™re writing high-assurance contracts

## ğŸ§ª TL;DR Table

| Pragma         | Status                            | Use                             |
| -------------- | --------------------------------- | ------------------------------- |
| `ABIEncoderV2` | Deprecated (non-experimental now) | Use `abicoder v2` instead       |
| `SMTChecker`   | Still experimental                | Enables static logic bug checks |
