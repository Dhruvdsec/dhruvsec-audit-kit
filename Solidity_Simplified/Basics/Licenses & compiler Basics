# 📄 SPDX License Identifiers in Solidity (Simplified)


## 🔐 Why License Matters

When you open-source a smart contract, you’re giving others permission to read, reuse, or build upon your code — but only under certain legal terms. That’s where SPDX license identifiers come in.


## ✅ Syntax (Top of every `.sol` file)

// SPDX-License-Identifier: MIT

This tells the compiler (and the world):

> "I’m open-sourcing this file under the MIT License."


## 📚 Common SPDX License Types

| SPDX Tag     | Meaning                                                                    |
| ------------ | -------------------------------------------------------------------------- |
| `MIT`        | Super permissive. You can use, copy, modify, distribute. Just give credit. |
| `GPL-3.0`    | Free to use, but **must open-source** derivative works.                    |
| `Apache-2.0` | Like MIT, but with added patent protection.                                |
| `UNLICENSED` | You are **not** allowing others to use or reuse the code.                  |
| `UNLICENSE`  | You are granting **all rights** to everyone — public domain.               |

> ⚠️ `UNLICENSED` ≠ `UNLICENSE` — Don’t get confused


## 📌 Best Practices

* Always add an SPDX license identifier in production contracts
* Place it at the very top of every `.sol` file
* Choose the license that fits the level of openness you want


## ✅ Example

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract HelloWorld {
    string public greet = "Hello, world!";
}


## 🧠 Compiler Notes

* The Solidity compiler does **not** validate the license — it just embeds it in bytecode metadata.
* SPDX tags are **machine-readable** — useful for automated tools, scanners, and legal audits.

# ⚙️ `pragma` in Solidity — Explained

The `pragma` keyword tells the Solidity compiler to enable specific features or set version requirements — it's a compiler instruction.


## 🔎 Key Points

* `pragma` is **file-scoped** — it only applies to the file it's written in
* It does **not** affect imported files
* You must repeat it in every relevant file


## ✅ Most Common — Version Pragma

pragma solidity ^0.8.20;


> Tells the compiler to compile using Solidity version 0.8.20 or higher (upward compatible)

pragma solidity >=0.8.0 <0.9.0;

> Limits compiler between versions 0.8.0 and 0.9.0 (good for safety in teams)

## 🛠 Common Pragma Directives

| Pragma                      | Purpose                                           |
| --------------------------- | ------------------------------------------------- |
| `abicoder v2`               | Enables ABI encoder v2 (default in Solidity 0.8+) |
| `experimental SMTChecker`   | Enables formal verification via SMT solver        |
| `experimental ABIEncoderV2` | Legacy way to enable encoder v2 (⚠️ deprecated)   |


## 📌 Best Practices

* Lock version for production with `^0.x.x`
* Use version ranges during development
* Don't assume pragma applies across imports — always declare explicitly


## ✅ Real Example

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Utils.sol"; // This file must also declare its own pragma


# 🔄 `abicoder v1` vs `v2` — ABI Encoding in Solidity

Solidity smart contracts often encode/decode complex data — especially when using **arrays** or **structs**.

The **ABI encoder** decides how this is done.


## ✅ Syntax

pragma abicoder v2;
// or
pragma abicoder v1;


## ⚙️ Differences

| Feature                 | abicoder v1     | abicoder v2 (Recommended)         |
| ----------------------- | --------------- | --------------------------------- |
| Nested Arrays / Structs | ❌ Not Supported | ✅ Fully Supported                 |
| Safety Checks           | ⚠️ Limited      | ✅ More thorough                   |
| Gas Usage               | ⛽ Lower         | ⛽ Slightly higher (due to checks) |
| Default in 0.8+         | ❌ No            | ✅ Yes                             |


## 📌 TL;DR:

* Use `abicoder v2` if dealing with complex types
* It’s **default in Solidity 0.8.0+** so no need to declare explicitly
* Only use `v1` if you’re compiling old code from before v0.8


# 🧪 Experimental Pragmas

Experimental pragmas unlock **in-development** compiler features. Use them only if you know what you're doing.


## ✅ Syntax

pragma experimental SMTChecker;


> Must be declared in each file you want it applied to


## 🧪 Supported Experimental Features

### 1. ⚠️ `ABIEncoderV2` (Deprecated)

pragma experimental ABIEncoderV2;

* Legacy way to enable encoder v2 in Solidity <0.8
* Not needed anymore in Solidity >=0.8.0

### 2. 🧠 `SMTChecker` — Formal Verification

pragma experimental SMTChecker;

* Enables static analysis using SMT solvers like **Z3**
* Helps catch:

  * 🔥 Logic bugs
  * 🚫 Integer overflows
  * 🧱 Unreachable code
  * ❌ Failing `assert()`

## 🛠️ Using SMTChecker

* Compiler must be built **with SMT support**

✅ Available in:

* Ubuntu PPA versions

❌ Not in:

* Docker images
* Static builds
* Remix (browser)

If using `solc-js`:

* Can be enabled with `smtCallback` if solver installed locally

## 📌 When to Use

Use SMTChecker if you are:

* Auditing contracts
* Writing critical financial protocols
* Doing formal verification for DeFi

## 🧪 TL;DR Table

| Pragma         | Status             | Use Case                     |
| -------------- | ------------------ | ---------------------------- |
| `ABIEncoderV2` | Deprecated         | Use `abicoder v2` instead    |
| `SMTChecker`   | Still experimental | Formal verification of logic |

