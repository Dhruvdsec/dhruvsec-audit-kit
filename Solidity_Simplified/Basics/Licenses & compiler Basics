# ğŸ“„ SPDX License Identifiers in Solidity (Simplified)


## ğŸ” Why License Matters

When you open-source a smart contract, youâ€™re giving others permission to read, reuse, or build upon your code â€” but only under certain legal terms. Thatâ€™s where SPDX license identifiers come in.


## âœ… Syntax (Top of every `.sol` file)

// SPDX-License-Identifier: MIT

This tells the compiler (and the world):

> "Iâ€™m open-sourcing this file under the MIT License."


## ğŸ“š Common SPDX License Types

| SPDX Tag     | Meaning                                                                    |
| ------------ | -------------------------------------------------------------------------- |
| `MIT`        | Super permissive. You can use, copy, modify, distribute. Just give credit. |
| `GPL-3.0`    | Free to use, but **must open-source** derivative works.                    |
| `Apache-2.0` | Like MIT, but with added patent protection.                                |
| `UNLICENSED` | You are **not** allowing others to use or reuse the code.                  |
| `UNLICENSE`  | You are granting **all rights** to everyone â€” public domain.               |

> âš ï¸ `UNLICENSED` â‰  `UNLICENSE` â€” Donâ€™t get confused


## ğŸ“Œ Best Practices

* Always add an SPDX license identifier in production contracts
* Place it at the very top of every `.sol` file
* Choose the license that fits the level of openness you want


## âœ… Example

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract HelloWorld {
    string public greet = "Hello, world!";
}


## ğŸ§  Compiler Notes

* The Solidity compiler does **not** validate the license â€” it just embeds it in bytecode metadata.
* SPDX tags are **machine-readable** â€” useful for automated tools, scanners, and legal audits.

# âš™ï¸ `pragma` in Solidity â€” Explained

The `pragma` keyword tells the Solidity compiler to enable specific features or set version requirements â€” it's a compiler instruction.


## ğŸ” Key Points

* `pragma` is **file-scoped** â€” it only applies to the file it's written in
* It does **not** affect imported files
* You must repeat it in every relevant file


## âœ… Most Common â€” Version Pragma

pragma solidity ^0.8.20;


> Tells the compiler to compile using Solidity version 0.8.20 or higher (upward compatible)

pragma solidity >=0.8.0 <0.9.0;

> Limits compiler between versions 0.8.0 and 0.9.0 (good for safety in teams)

## ğŸ›  Common Pragma Directives

| Pragma                      | Purpose                                           |
| --------------------------- | ------------------------------------------------- |
| `abicoder v2`               | Enables ABI encoder v2 (default in Solidity 0.8+) |
| `experimental SMTChecker`   | Enables formal verification via SMT solver        |
| `experimental ABIEncoderV2` | Legacy way to enable encoder v2 (âš ï¸ deprecated)   |


## ğŸ“Œ Best Practices

* Lock version for production with `^0.x.x`
* Use version ranges during development
* Don't assume pragma applies across imports â€” always declare explicitly


## âœ… Real Example

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Utils.sol"; // This file must also declare its own pragma


# ğŸ”„ `abicoder v1` vs `v2` â€” ABI Encoding in Solidity

Solidity smart contracts often encode/decode complex data â€” especially when using **arrays** or **structs**.

The **ABI encoder** decides how this is done.


## âœ… Syntax

pragma abicoder v2;
// or
pragma abicoder v1;


## âš™ï¸ Differences

| Feature                 | abicoder v1     | abicoder v2 (Recommended)         |
| ----------------------- | --------------- | --------------------------------- |
| Nested Arrays / Structs | âŒ Not Supported | âœ… Fully Supported                 |
| Safety Checks           | âš ï¸ Limited      | âœ… More thorough                   |
| Gas Usage               | â›½ Lower         | â›½ Slightly higher (due to checks) |
| Default in 0.8+         | âŒ No            | âœ… Yes                             |


## ğŸ“Œ TL;DR:

* Use `abicoder v2` if dealing with complex types
* Itâ€™s **default in Solidity 0.8.0+** so no need to declare explicitly
* Only use `v1` if youâ€™re compiling old code from before v0.8


# ğŸ§ª Experimental Pragmas

Experimental pragmas unlock **in-development** compiler features. Use them only if you know what you're doing.


## âœ… Syntax

pragma experimental SMTChecker;


> Must be declared in each file you want it applied to


## ğŸ§ª Supported Experimental Features

### 1. âš ï¸ `ABIEncoderV2` (Deprecated)

pragma experimental ABIEncoderV2;

* Legacy way to enable encoder v2 in Solidity <0.8
* Not needed anymore in Solidity >=0.8.0

### 2. ğŸ§  `SMTChecker` â€” Formal Verification

pragma experimental SMTChecker;

* Enables static analysis using SMT solvers like **Z3**
* Helps catch:

  * ğŸ”¥ Logic bugs
  * ğŸš« Integer overflows
  * ğŸ§± Unreachable code
  * âŒ Failing `assert()`

## ğŸ› ï¸ Using SMTChecker

* Compiler must be built **with SMT support**

âœ… Available in:

* Ubuntu PPA versions

âŒ Not in:

* Docker images
* Static builds
* Remix (browser)

If using `solc-js`:

* Can be enabled with `smtCallback` if solver installed locally

## ğŸ“Œ When to Use

Use SMTChecker if you are:

* Auditing contracts
* Writing critical financial protocols
* Doing formal verification for DeFi

## ğŸ§ª TL;DR Table

| Pragma         | Status             | Use Case                     |
| -------------- | ------------------ | ---------------------------- |
| `ABIEncoderV2` | Deprecated         | Use `abicoder v2` instead    |
| `SMTChecker`   | Still experimental | Formal verification of logic |

