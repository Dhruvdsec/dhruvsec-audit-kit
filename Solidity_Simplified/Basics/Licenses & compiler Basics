# SPDX License Identifiers in Solidity (Simplified)

## 🔐 Why License Matters

When you open-source a smart contract, you’re giving others permission to read, reuse, or build upon your code — but only under certain legal terms. That’s where SPDX license identifiers come in.

### ✅ Syntax (Put this at the top of every `.sol` file):

```solidity
// SPDX-License-Identifier: MIT
```

This tells the compiler (and the world):

> “I’m open-sourcing this file under the MIT License.”

## 📚 Common SPDX License Types

| SPDX Tag     | Meaning                                                                    |
| ------------ | -------------------------------------------------------------------------- |
| `MIT`        | Super permissive. You can use, copy, modify, distribute. Just give credit. |
| `GPL-3.0`    | Free to use, but **must open-source** derivative works.                    |
| `Apache-2.0` | Similar to MIT but with extra legal protections (like patent rights).      |
| `UNLICENSED` | You are **not** allowing others to use or reuse the code.                  |
| `UNLICENSE`  | You are granting **all rights** to everyone — public domain.               |

### ⚠️ Note:

* `UNLICENSED` ≠ `UNLICENSE` — don’t get confused
* Compiler doesn’t validate the license — it just attaches your string to the compiled bytecode
* SPDX tag is machine-readable, good for tooling, scanners, and legal audits

### 📌 Best Practices:

* Always add the SPDX license identifier in production code
* Put it at the very top of every file, before the pragma
* Pick the license based on how much freedom you're giving others

### ✅ Example:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract HelloWorld {
    string public greet = "Hello, world!";
}
```

---

# ⚙️ `pragma` in Solidity — Explained

The `pragma` keyword in Solidity is like a compiler instruction. It tells the Solidity compiler to enable specific features or checks for that particular source file.

### 🧠 Key Points:

* `pragma` applies **only** to the file it’s written in
* It does **not** carry over to imported files
* You need to repeat it in every `.sol` file where it matters

### ✅ Most Common: Solidity Version Pragma

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
```

This tells the compiler:

> “Compile this file using Solidity version 0.8.20 or compatible upward versions”

You can also specify version ranges:

```solidity
pragma solidity >=0.8.0 <0.9.0;
```

## ⚙️ Common `pragma` Directives in Solidity

| Pragma                      | Purpose                                             |
| --------------------------- | --------------------------------------------------- |
| `abicoder v2`               | Enables ABI encoder v2 (default from Solidity 0.8+) |
| `experimental SMTChecker`   | Enables formal verification via SMT solver          |
| `experimental ABIEncoderV2` | Old version for encoder v2 (⚠️ deprecated)          |

### ⚠️ Best Practices:

* Always lock the compiler version in production contracts (e.g., `^0.8.20`) to avoid unexpected behavior
* Use a version range in dev if working across multiple contracts
* Don’t assume `pragma` in one file affects others — be explicit!

### ✅ Real Example:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import "./Utils.sol";  // Must also have its own pragma
```

Even if `Utils.sol` has pragma, you must still declare pragma in your main file.

---

# 🔄 `pragma abicoder v1` vs `v2` — ABI Encoder in Solidity

Solidity smart contracts need to encode and decode data when calling functions or returning results — especially when structs, arrays, or nested data types are involved. This is handled by the ABI Encoder.

### ✅ Syntax:

```solidity
pragma abicoder v2;
// or
pragma abicoder v1;
```

### ✅ Why It Matters:

* `v2` supports nested structs and arrays
* `v1` does **not** support these
* `v2` has more safety checks (but may cost more gas)

> Since Solidity `0.8.0`, `v2` is enabled by default

---

# 🧪 Experimental Pragmas in Solidity

Experimental pragmas are used to enable **advanced** or **in-development** features of the Solidity compiler — stuff that’s not yet enabled by default.

### ✅ Syntax:

```solidity
pragma experimental SMTChecker;
```

They are **file-local**, just like other pragmas.

## 🧠 Currently Supported Experimental Pragmas

### 1. 🚫 `ABIEncoderV2` (Deprecated as Experimental)

```solidity
pragma experimental ABIEncoderV2;
```

* Old way to enable support for nested arrays and structs
* Not needed in Solidity 0.8.0+
* Use **only** if you’re stuck using 0.6.x or 0.7.x

### 2. 🧠 `SMTChecker` — Formal Verification

```solidity
pragma experimental SMTChecker;
```

#### What It Does:

* Enables formal verification using SMT solvers like Z3
* Checks for:

  * Assertion failures
  * Integer overflows
  * Unreachable code

#### 🔥 Real Use Case:

If you’re writing **critical DeFi contracts** or doing audits, SMTChecker can detect:

* Integer overflows (even without SafeMath)
* Dead code
* Logical errors pre-runtime

#### 🛠️ How to Use It:

You need a compiler that was **built with SMT support**

* ✅ Available in: Ubuntu PPA versions
* ❌ Not in: Docker, Windows binaries, static Linux builds

If using `solc-js`:

* Enable via `smtCallback` (with a local solver)
* Won’t work in-browser (e.g., Remix)

### ⚠️ Important:

Experimental pragmas are **not for beginners**
Only use them if:

* You’re on a compatible compiler
* You understand what the feature does
* You’re writing high-assurance contracts

## 🧪 TL;DR Table

| Pragma         | Status                            | Use                             |
| -------------- | --------------------------------- | ------------------------------- |
| `ABIEncoderV2` | Deprecated (non-experimental now) | Use `abicoder v2` instead       |
| `SMTChecker`   | Still experimental                | Enables static logic bug checks |
